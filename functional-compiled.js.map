{"version":3,"sources":["functional.js"],"names":[],"mappings":"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","file":"functional-compiled.js","sourcesContent":["\tvar\n\n\t\t/**\n\t\t * curry\n\t\t *\n\t\t * this function will take a function and curry the arguments\n\t\t *\n\t\t * @param   {Function}  fn          function to curry\n\t\t *\n\t\t * @returns {Function}              curried function with arguments\n\t\t */\n\t\tcurry       =   ( fn ) =>{\n\t\t\t\t\t\t\tvar ll = fn.length,\n\t\t\t\t\t\t    _curry = ( _args_ ) =>\n\t\t\t\t\t\t\t    ( ...args ) =>{\n\t\t\t\t\t\t\t\t    var a = _args_.concat( args );\n\t\t\t\t\t\t\t\t    return a.length >= ll\n\t\t\t\t\t\t\t\t\t    ? fn.apply( this, a )\n\t\t\t\t\t\t\t\t\t    : _curry( a );\n\t\t\t\t\t\t\t    };\n\t\t\t\t\t\t\treturn _curry( [] );\n\t\t\t\t\t},\n\n\t\t/**\n\t\t * curryArgs\n\t\t *\n\t\t * this function will take a function and curry the arguments, set with argLength\n\t\t *\n\t\t * @param   {Function}  fn          function to curry\n\t\t * @param   {Number}    argLength   amount of arguments to curry before calling the function\n\t\t *\n\t\t * @returns {Function}              curried function with arguments\n\t\t */\n\t\tcurryArgs   =   ( fn, argLength ) => {\n\t\t\t\t\t\t\tvar _curry = ( _args_ ) =>\n\t\t\t\t\t\t\t\t( ...args ) => {\n\t\t\t\t\t\t\t\t\tvar a = _args_.concat( args );\n\t\t\t\t\t\t\t\t\treturn a.length >= argLength\n\t\t\t\t\t\t\t\t\t\t? fn.apply( this, a )\n\t\t\t\t\t\t\t\t\t\t: _curry( a );\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn _curry( [] );\n\t\t\t\t\t\t},\n\n\n\t\t/**\n\t\t * flipAll\n\t\t *\n\t\t * this function will reverse all arguments provided to function\n\t\t *\n\t\t * ` flip( Function:fn ) ( *:...arguments ); `\n\t\t *\n\t\t * @param   {Function}  fn          function to flip arguments\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param   {*}         [args]      arguments to flip to function\n \t\t */\n\t\tflipAll     =   ( fn ) =>\n\t\t\t\t\t\t\t( ...args ) =>\n\t\t\t\t\t\t\t\tfn.apply( this, args.reverse() ),\n\n\n\t\t/**\n\t\t * flip\n\t\t *\n\t\t * this function will take a function and apply 2 arguments to it in reverse.\n\t\t * if second argument is not provided a curried function will be returned\n\t\t *\n\t\t * ` flip( Function:fn ) ( *:first, *:second ); `\n\t\t *\n\t\t * @param   {Function}  fn          function to flip arguments\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param   {*}         first       first argument\n\t\t *      @param   {*}         second      second argument\n \t\t */\n\t\tflip        =   ( fn ) =>\n\t\t\t\t\t\t\t( first, second ) => {\n\t\t\t\t\t\t\t\treturn second\n\t\t\t\t\t\t\t\t\t? _flip( second )\n\t\t\t\t\t\t\t\t\t: _flip;\n\t\t\t\t\t\t\t\tfunction _flip(second) {\n\t\t\t\t\t\t\t\t\treturn fn.call(this, second, first)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\n\n\t\t/**\n\t\t * first\n\t\t *\n\t\t * this function will pass only the first argument to the curried isFunction\n\t\t *\n\t\t * ` first( Function:fn ) ( *:first ); `\n\t\t *\n\t\t * @param   {Function}  fn          function to call\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param   {*}         first       argument to pass to function\n \t\t */\n\t\tfirst       =   ( fn ) =>\n\t\t\t\t\t\t\t( first ) =>\n\t\t\t\t\t\t\t\tfn.call( this, first ),\n\n\t\t/**\n\t\t * arrProto\n\t\t *\n\t\t * this function will curry an array method and return a curried function\n\t\t * that can use the method\n\t\t *\n\t\t * ` arrProto( String:method ); `\n\t\t *\n\t\t * @method  {String}    method      Array method identifier\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Array}     arr         Array to apply prototype method to\n\t\t *      @param  [{*}]       args        arguments to apply to the prototype method\n\t\t */\n\t\tarrProto    =   ( method ) => {\n\t\t\t\t\t\t\tmethod = Array.prototype[ method ];\n\t\t\t\t\t\t\treturn ( arr, ...args ) =>\n\t\t\t\t\t\t\t\tmethod.apply( arr, args );\n\t\t\t\t\t\t},\n\n\t\t/**\n\t\t * slice\n\t\t *\n\t\t * this function will slice the provided array\n\t\t *\n\t\t * ` slice( Array:arr [, Int:start ] ); `\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Array}     arr         Array to slice\n\t\t *      @param  {Number}    start       Array index to slice from\n\t\t */\n\t\tslice       =   arrProto( 'slice' ),\n\n\n\n\t\t/**\n\t\t * map\n\t\t *\n\t\t * this function will map over the provided array\n\t\t *\n\t\t * ` map( Array ) => ( Function( el [, Int:ii, Array:arr ] ){  } ); `\n\t\t *\n\t\t * @param  {Array}     arr         Array to slice\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Function}  fn          Function to call for each index of the Array\n\t\t *\n\t\t *      @returns {Array}                mapped array return values\n\t\t */\n\t\tmap         =   arrProto( 'map' ),\n\n\n\t\t/**\n\t\t * mapWith\n\t\t *\n\t\t * this function will curry a function to map over the provided array\n\t\t *\n\t\t * ` map( Function( el [, Int:ii, Array:arr ] ){  } ) => ( Array:arr ) `\n\t\t *\n\t\t * @param  {Function}  fn          Function to call for each index of the Array\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Array}     arr         Array to slice\n\t\t *\n\t\t *      @returns {Array}                mapped array return values\n\t\t */\n\t\tmapWith     =   flip( map ),\n\n\t\tparseIntMap    = mapWith( first(parseInt)),\n\t\thexToDecMap    = mapWith( ( hex ) => parseInt(hex, 16) ),\n\t\tnegativeMap    = mapWith(( num ) => num * -1),\n\n\t\t/**\n\t\t * filter\n\t\t *\n\t\t * this function will filter the provided array, returning a new array\n\t\t * filtering out any element that does not return true\n\t\t *\n\t\t * ` filter( Array, Function( el [, Int:ii, Array:arr ] ){  } ); `\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Array}     arr         Array to slice\n\t\t *      @param  {Function}  fn          Function to call for each index of the Array\n\t\t *\n\t\t *      @returns {Array}                mapped array return values\n\t\t */\n\t\tfilter      =   arrProto( 'filter' ),\n\n\n\t\t/**\n\t\t * filterWith\n\t\t *\n\t\t * this function will curry a filter function, and wait for an array\n\t\t * to filter.\n\t\t *\n\t\t * ` filter( Function( el [, Int:ii, Array:arr ] ){  } ) ( Array:arr )`\n\t\t *\n\t\t * @param  {Function}  fn          Function to call for each index of the Array\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Array}     arr         Array to slice\n\t\t *\n\t\t *      @returns {Array}                mapped array return values\n\t\t */\n\t\tfilterWith  =   flip( filter ),\n\n\n\t\t/**\n\t\t * get\n\t\t *\n\t\t * this function will curry an object and return a getter for the object\n\t\t *\n\t\t * @param   {Object}    obj         Object to get properties from\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {String}    item        property key to retrieve from the Object\n\t\t *\n\t\t *      @returns {*}                    property of object\n \t\t */\n\t\tget         =   ( obj ) =>\n\t\t\t\t\t\t\t( item ) =>\n\t\t\t\t\t\t\t\tobj[ item ],\n\n\n\t\t/**\n\t\t * compase\n\t\t *\n\t\t * this function will combine and curry two functions, the return function will take\n\t\t * another function which will be passed through the curried functions\n\t\t *\n\t\t * ` compose( third, second ) => ( first ) `\n\t\t *\n\t\t * @param   {Function}  a           last function in the chain\n\t\t * @param   {Function}  b           second function in the chain\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Function}  c           first function in the chain\n\t\t */\n\t\tcompose     =   ( a, b ) =>\n\t\t\t\t\t\t\t( c ) =>\n\t\t\t\t\t\t\t\ta( b( c ) ),\n\n\n\t\t/**\n\t\t * pipe\n\t\t *\n\t\t * pipe will compose two functions together, but respect the order of the arguments\n\t\t *\n\t\t * ` pipe( second, third ) => ( first ) `\n\t\t *\n\t\t * @param   {Function}  a           second function in the chain\n\t\t * @param   {Function}  b           third function in the chain\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {Function}  c           first function in the chain\n\t\t */\n\t\tpipe        =   flipAll( compose ),\n\n\n\t\t/**\n\t\t * callFirst\n\t\t *\n\t\t * this will partially apply a function and the first arg, returned function will take\n\t\t * remaining arguments and apply to the curried function\n\t\t *\n\t\t * ` callFirst( Function( ...arguments ), first ) => ( ...arguments ) `\n\t\t *\n\t\t * @param   {Function}  fn          curried function\n\t\t * @param   {*}         first       first argument\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  [{*}]       args        arguments to apply to curried function\n \t\t */\n\t\tcallFirst   =   ( fn, first ) =>\n\t\t\t\t\t\t\t( ...args ) =>\n\t\t\t\t\t\t\t\tfn.apply(this, [ first ].concat( args ) ),\n\n\n\t\t/**\n\t\t * callLast\n\t\t *\n\t\t * this will partially apply a function and the last arg, returned function will take\n\t\t * remaining arguments and apply to the curried function\n\t\t *\n\t\t * ` callFirst( Function( ...arguments ), last ) => ( ...arguments ) `\n\t\t *\n\t\t * @param   {Function}  fn          curried function\n\t\t * @param   {*}         last        last argument\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  [{*}]       args        arguments to apply to curried function\n\t\t */\n\t\tcallLast    =   ( fn, last ) =>\n\t\t\t\t\t\t\t( ...args ) =>\n\t\t\t\t\t\t\t\tfn.apply(this, args.concat( [ last ] ) ),\n\n\n\t\t/**\n\t\t * curryOne\n\t\t *\n\t\t * this function will curry a function taking one argument\n\t\t *\n\t\t * ` curryOne( Function ) => ( *:arg ) `\n\t\t *\n\t\t * @param   {Function}  fn          function to curry\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {*]         arg         argument to apply to curried function\n\t\t *\n\t\t *      @returns {*}                    return from curried function\n \t\t */\n\t\tcurryOne    =   ( fn ) =>\n\t\t\t\t\t\t\t( arg ) =>\n\t\t\t\t\t\t\t\tfn.call( this, arg ),\n\n\n\t\t/**\n\t\t * curryOne\n\t\t *\n\t\t * this function will curry a function taking one argument\n\t\t *\n\t\t * @param   {Function}  fn          function to curry\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {*]         arg         argument to apply to curried function\n\t\t *\n\t\t *      @returns {*}                    return from curried function\n\t\t */\n\t\tcurryTwo    =   ( fn ) =>\n\t\t\t\t\t\t\t( arg ) =>\n\t\t\t\t\t\t\t\tcallFirst(fn, arg ),\n\n\n\t\t/**\n\t\t * curryThree\n\t\t *\n\t\t * this function will curry a function taking three arguments\n\t\t *\n\t\t * ` curryTwo( Function ) => ( first ) => ( second ) => ( third ); `\n\t\t *\n\t\t * @param   {Function}  fn          function to curry\n\t\t *\n\t\t * @returns {Function}      curryTwo\n \t\t */\n\t\tcurryThree  =   ( fn ) =>\n\t\t\t\t\t\t\t( arg ) =>\n\t\t\t\t\t\t\t\tcurryTwo(callFirst(fn, arg )),\n\n\n\t\t/**\n\t\t * fluent\n\t\t *\n\t\t * this decorator will return the owning object if no return\n\t\t * value is given to the curried function\n\t\t *\n\t\t * @param {Function}    method      method to decorate\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  [{*}]       args        arguments for curried method\n\t\t *\n\t\t *      @returns    {*}                 value of this abj\n \t\t */\n\t\tfluent      =   ( method ) =>\n\t\t\t\t\t\t\tfunction fluent( ...args ){\n\t\t\t\t\t\t\t\tvar ret = method.apply( this, args );\n\t\t\t\t\t\t\t\treturn typeof ret !== 'undefined'\n\t\t\t\t\t\t\t\t\t? ret\n\t\t\t\t\t\t\t\t\t: this\n\t\t\t\t\t\t\t},\n\n\t\t/**\n\t\t * maybe\n\t\t *\n\t\t * this function will only execute the curried function on an object\n\t\t * if none of the arguments are nully\n \t\t */\n\t\tmaybe       =   ( fn ) =>\n\t\t\t\t\t\t\tfunction maybe( ...args ){\n\t\t\t\t\t\t\t\treturn args.length === 0 || containsNully( args )\n\t\t\t\t\t\t\t\t\t? void 0\n\t\t\t\t\t\t\t\t\t: fn.apply(this, args );\n\t\t\t\t\t\t\t},\n\n\n\t\tcurriedMapWith =    curryTwo( flip( map ) ),\n\n\t\t/**\n\t\t * setter\n\t\t *\n\t\t * this decorator will only set a property's value if the arguments are\n\t\t * not null, and will return the value or this for fluent chaining\n\t\t */\n\t\tsetter      =       compose( fluent, maybe ),\n\n\t\t/**\n\t\t * not\n\t\t *\n\t\t * this function will return the inverse of the curried function\n\t\t *\n\t\t * @param {Function}    fn          function to curry\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  {*}         args        arguments to apply to curried function\n \t\t */\n\t\tnot         =   ( fn ) =>\n\t\t\t\t\t\t\tfunction( ...args ){\n\t\t\t\t\t\t\t\treturn !fn.apply( this, args );\n\t\t\t\t\t\t\t},\n\n\n\t\t/**\n\t\t * bind\n\t\t *\n\t\t * this function will bind arguments to a curried function\n\t\t *\n\t\t * ` bind( Function [, *:...bound] ) => ( *:...passed ) `\n\t\t *\n\t\t * @param {Function}    fn          function to curry\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param  [{*}]       bound       arguments to bind to curried function\n\t\t *\n\t\t *      @returns {Function}\n\t\t *\n\t\t *          @param [{*}]        passed      arguments passed when calling bound function\n\t\t *\n\t\t *          @returns {*}                    result of curried function\n \t\t */\n\t\tbind        =   ( fn ) =>\n\t\t\t\t\t\t\t( ...bound ) =>\n\t\t\t\t\t\t\t\tfunction( ...passed ) {\n\t\t\t\t\t\t\t\t\treturn fn.apply(this, bound.concat( passed ))\n\t\t\t\t\t\t\t\t},\n\n\n\t\t/**\n\t\t * typeIs\n\t\t *\n\t\t * this function will curry a property value, and return a function that takes\n\t\t * a value to compare.\n\t\t *\n\t\t * `typeIs( *:prop ) => ( *:val )`\n\t\t *\n\t\t * @param {*}       prop            a type of object\n\t\t *\n\t\t * @returns {Function}\n\t\t *\n\t\t *      @param {*}       val             a value to check against the type\n\t\t *\n\t\t *      @returns {Boolean}\n \t\t */\n\t\ttypeIs      =   ( prop ) =>\n\t\t\t\t\t\t\t( val ) =>\n\t\t\t\t\t\t\t\ttypeof val === prop,\n\n\n\t\tisInstance  =   ( instance ) =>\n\t\t\t\t\t\t\t( thing ) =>\n\t\t\t\t\t\t\t\tthing instanceof instance,\n\n\n\t\tisUndefined =   typeIs( 'undefined' ),\n\n\n\t\tnotUndefined=   not(isUndefined),\n\n\n\t\tisFunction  =   typeIs('function'),\n\n\t\tisElement   =   isInstance(HTMLElement),\n\t\tisNodeList  =   isInstance(NodeList),\n\n\t\tisString    =   typeIs('string'),\n\n\t\tisNully = ( val ) => val == null,\n\t\tnullyFilter = filterWith( not(isNully) ),\n\t\tcount = ( thing ) => thing.length,\n\t\tcontainsNully = compose( count, filterWith( isNully ) ),\n\n\t\t/**\n\t\t * this function will return an array of the values not\n\t\t * contained in the input array\n\t\t *\n\t\t * @param   {Array}     arr         array to check\n\t\t * @param   {Array}     values      array to compare\n\t\t *\n\t\t * @returns {Array}     values not in input array\n \t\t */\n\t\tnotIn       = (arr, ...values ) =>\n\t\t\tvalues.filter(( item ) => arr.indexOf(item) > -1 ),\n\n\n\t\tcombine     =   ( arr ) =>\n\t\t\t\t\t\t\t( ...values ) => {\n\t\t\t\t\t\t\t\tvar index = null;\n\t\t\t\t\t\t\t\tvalues = arr.concat( notIn(arr, values ));\n\t\t\t\t\t\t\t},\n\n\n\t\tdiff        =   ( one, two ) =>\n\t\t\t\t\t\t\tone < two\n\t\t\t\t\t\t\t\t? two - one\n\t\t\t\t\t\t\t\t: ( one - two ) * -1,\n\n\t\tdiffArray   =   (left, right) => {\n\t\t\t\t\t\t\tvar ret = [],\n\t\t\t\t\t\t\t\tii = 0,\n\t\t\t\t\t\t\t\tll = left.length;\n\n\t\t\t\t\t\t\tfor( ; ii < ll; ii++ ){\n\t\t\t\t\t\t\t\tret.push(diff( left[ii], right[ii] ));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t},\n\n\n\t\tgetSet      =   ( prop, fn ) => {\n\t\t\t\t\t\t\treturn fluent(function( val ){\n\t\t\t\t\t\t\t\tif( isUndefined( val ) ){\n\t\t\t\t\t\t\t\t\treturn this[ prop ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\textend( this[ prop ], val );\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t},\n\n\n\t\tcapitalize  =   ( str ) =>\n\t\t\t\t\t\t\tstr.replace(/(\\w)(\\w*)/, ( matches, first, rest) =>\n\t\t\t\t\t\t\t\tfirst.toUpperCase() + rest ),\n\n\n\t    crossBrowser =  (...browsers) =>\n\t\t\t\t\t\t    ( prop ) =>\n\t\t\t\t\t\t\t    ( el, value ) => {\n\t\t\t\t\t\t\t\t    browsers.forEach(( browser ) =>\n\t\t\t\t\t\t\t\t\t    el.style[browser + '-' + capitalize( prop ) ] = value );\n\n\t\t\t\t\t\t\t\t    el.style[ prop ] = value;\n\t                            },\n\n\n\t    allBrowsers =   crossBrowser('webkit', 'moz', 'ms' ),\n\n\n\t    transform   =   allBrowsers('transform');\n\n\n\tfunction extend( reciever, ...givers ){\n\t\treturn givers.reduce(function( reciever, giver ){\n\n\t\t\tfor( var key in giver ){\n\t\t\t\treciever[ key ] = giver[ key ];\n\t\t\t}\n\n\t\t\treturn reciever;\n\n\t\t}, reciever )\n\t}\n\n\n\n\textend.fluent = function( reciever, ...givers ){\n\t\treturn givers.reduce( function( reciever, giver ){\n\n\t\t\tfor( var key in giver ) {\n\t\t\t\treciever[ key ] = fluent(giver[ key ]);\n\t\t\t}\n\n\t\t\treturn reciever;\n\n\t\t}, reciever )\n\t};\n\n\n\t// this should force re compiling force again bitches"]}