{"version":3,"sources":["functional.js"],"names":[],"mappings":"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","file":"functional-compiled.js","sourcesContent":["\tvar\r\n\r\n\t\t/**\r\n\t\t * curry\r\n\t\t *\r\n\t\t * this function will take a function and curry the arguments\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to curry\r\n\t\t *\r\n\t\t * @returns {Function}              curried function with arguments\r\n\t\t */\r\n\t\tcurry =   ( fn ) =>{\r\n\t\t\t\tvar ll = fn.length,\r\n\t\t\t\t\t_curry = ( _args_ ) =>\r\n\t\t\t\t\t\t( ...args ) =>{\r\n\t\t\t\t\t\t\tvar a = _args_.concat( args );\r\n\t\t\t\t\t\t\treturn a.length >= ll\r\n\t\t\t\t\t\t\t\t? fn.apply( this, a )\r\n\t\t\t\t\t\t\t\t: _curry( a );\r\n\t\t\t\t\t\t};\r\n\t\t\t\treturn _curry( [] );\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * curryArgs\r\n\t\t *\r\n\t\t * this function will take a function and curry the arguments, set with argLength\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to curry\r\n\t\t * @param   {Number}    argLength   amount of arguments to curry before calling the function\r\n\t\t *\r\n\t\t * @returns {Function}              curried function with arguments\r\n\t\t */\r\n\t\tcurryArgs   =   ( fn, argLength ) => {\r\n\t\t\t\t\t\t\tvar _curry = ( _args_ ) =>\r\n\t\t\t\t\t\t\t\t( ...args ) => {\r\n\t\t\t\t\t\t\t\t\tvar a = _args_.concat( args );\r\n\t\t\t\t\t\t\t\t\treturn a.length >= argLength\r\n\t\t\t\t\t\t\t\t\t\t? fn.apply( this, a )\r\n\t\t\t\t\t\t\t\t\t\t: _curry( a );\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\treturn _curry( [] );\r\n\t\t\t\t\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * flipAll\r\n\t\t *\r\n\t\t * this function will reverse all arguments provided to function\r\n\t\t *\r\n\t\t * ` flip( Function:fn ) ( *:...arguments ); `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to flip arguments\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param   {*}         [args]      arguments to flip to function\r\n \t\t */\r\n\t\tflipAll     =   ( fn ) =>\r\n\t\t\t\t\t\t\t( ...args ) =>\r\n\t\t\t\t\t\t\t\tfn.apply( this, args.reverse() ),\r\n\r\n\r\n\t\t/**\r\n\t\t * flip\r\n\t\t *\r\n\t\t * this function will take a function and apply 2 arguments to it in reverse.\r\n\t\t * if second argument is not provided a curried function will be returned\r\n\t\t *\r\n\t\t * ` flip( Function:fn ) ( *:first, *:second ); `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to flip arguments\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param   {*}         first       first argument\r\n\t\t *      @param   {*}         second      second argument\r\n \t\t */\r\n\t\tflip        =   ( fn ) =>\r\n\t\t\t\t\t\t\t( first, second ) => {\r\n\t\t\t\t\t\t\t\treturn second\r\n\t\t\t\t\t\t\t\t\t? _flip( second )\r\n\t\t\t\t\t\t\t\t\t: _flip;\r\n\t\t\t\t\t\t\t\tfunction _flip(second) {\r\n\t\t\t\t\t\t\t\t\treturn fn.call(this, second, first)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * first\r\n\t\t *\r\n\t\t * this function will pass only the first argument to the curried isFunction\r\n\t\t *\r\n\t\t * ` first( Function:fn ) ( *:first ); `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to call\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param   {*}         first       argument to pass to function\r\n \t\t */\r\n\t\tfirst       =   ( fn ) =>\r\n\t\t\t\t\t\t\t( first ) =>\r\n\t\t\t\t\t\t\t\tfn.call( this, first ),\r\n\r\n\t\t/**\r\n\t\t * arrProto\r\n\t\t *\r\n\t\t * this function will curry an array method and return a curried function\r\n\t\t * that can use the method\r\n\t\t *\r\n\t\t * ` arrProto( String:method ); `\r\n\t\t *\r\n\t\t * @method  {String}    method      Array method identifier\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Array}     arr         Array to apply prototype method to\r\n\t\t *      @param  [{*}]       args        arguments to apply to the prototype method\r\n\t\t */\r\n\t\tarrProto    =   ( method ) => {\r\n\t\t\t\t\t\t\tmethod = Array.prototype[ method ];\r\n\t\t\t\t\t\t\treturn ( arr, ...args ) =>\r\n\t\t\t\t\t\t\t\tmethod.apply( arr, args );\r\n\t\t\t\t\t\t},\r\n\r\n\t\t/**\r\n\t\t * slice\r\n\t\t *\r\n\t\t * this function will slice the provided array\r\n\t\t *\r\n\t\t * ` slice( Array:arr [, Int:start ] ); `\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Array}     arr         Array to slice\r\n\t\t *      @param  {Number}    start       Array index to slice from\r\n\t\t */\r\n\t\tslice       =   arrProto( 'slice' ),\r\n\r\n\r\n\r\n\t\t/**\r\n\t\t * map\r\n\t\t *\r\n\t\t * this function will map over the provided array\r\n\t\t *\r\n\t\t * ` map( Array ) => ( Function( el [, Int:ii, Array:arr ] ){  } ); `\r\n\t\t *\r\n\t\t * @param  {Array}     arr         Array to slice\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Function}  fn          Function to call for each index of the Array\r\n\t\t *\r\n\t\t *      @returns {Array}                mapped array return values\r\n\t\t */\r\n\t\tmap         =   arrProto( 'map' ),\r\n\r\n\r\n\t\t/**\r\n\t\t * mapWith\r\n\t\t *\r\n\t\t * this function will curry a function to map over the provided array\r\n\t\t *\r\n\t\t * ` map( Function( el [, Int:ii, Array:arr ] ){  } ) => ( Array:arr ) `\r\n\t\t *\r\n\t\t * @param  {Function}  fn          Function to call for each index of the Array\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Array}     arr         Array to slice\r\n\t\t *\r\n\t\t *      @returns {Array}                mapped array return values\r\n\t\t */\r\n\t\tmapWith     =   flip( map ),\r\n\r\n\t\tparseIntMap    = mapWith( first(parseInt)),\r\n\t\thexToDecMap    = mapWith( ( hex ) => parseInt(hex, 16) ),\r\n\t\tnegativeMap    = mapWith(( num ) => num * -1),\r\n\r\n\t\t/**\r\n\t\t * filter\r\n\t\t *\r\n\t\t * this function will filter the provided array, returning a new array\r\n\t\t * filtering out any element that does not return true\r\n\t\t *\r\n\t\t * ` filter( Array, Function( el [, Int:ii, Array:arr ] ){  } ); `\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Array}     arr         Array to slice\r\n\t\t *      @param  {Function}  fn          Function to call for each index of the Array\r\n\t\t *\r\n\t\t *      @returns {Array}                mapped array return values\r\n\t\t */\r\n\t\tfilter      =   arrProto( 'filter' ),\r\n\r\n\r\n\t\t/**\r\n\t\t * filterWith\r\n\t\t *\r\n\t\t * this function will curry a filter function, and wait for an array\r\n\t\t * to filter.\r\n\t\t *\r\n\t\t * ` filter( Function( el [, Int:ii, Array:arr ] ){  } ) ( Array:arr )`\r\n\t\t *\r\n\t\t * @param  {Function}  fn          Function to call for each index of the Array\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Array}     arr         Array to slice\r\n\t\t *\r\n\t\t *      @returns {Array}                mapped array return values\r\n\t\t */\r\n\t\tfilterWith  =   flip( filter ),\r\n\r\n\r\n\t\t/**\r\n\t\t * get\r\n\t\t *\r\n\t\t * this function will curry an object and return a getter for the object\r\n\t\t *\r\n\t\t * @param   {Object}    obj         Object to get properties from\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {String}    item        property key to retrieve from the Object\r\n\t\t *\r\n\t\t *      @returns {*}                    property of object\r\n \t\t */\r\n\t\tget         =   ( obj ) =>\r\n\t\t\t\t\t\t\t( item ) =>\r\n\t\t\t\t\t\t\t\tobj[ item ],\r\n\r\n\r\n\t\t/**\r\n\t\t * compase\r\n\t\t *\r\n\t\t * this function will combine and curry two functions, the return function will take\r\n\t\t * another function which will be passed through the curried functions\r\n\t\t *\r\n\t\t * ` compose( third, second ) => ( first ) `\r\n\t\t *\r\n\t\t * @param   {Function}  a           last function in the chain\r\n\t\t * @param   {Function}  b           second function in the chain\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Function}  c           first function in the chain\r\n\t\t */\r\n\t\tcompose     =   ( a, b ) =>\r\n\t\t\t\t\t\t\t( c ) =>\r\n\t\t\t\t\t\t\t\ta( b( c ) ),\r\n\r\n\t\t/**\r\n\t\t * pipe\r\n\t\t *\r\n\t\t * pipe will compose two functions together, but respect the order of the arguments\r\n\t\t *\r\n\t\t * ` pipe( second, third ) => ( first ) `\r\n\t\t *\r\n\t\t * @param   {Function}  a           second function in the chain\r\n\t\t * @param   {Function}  b           third function in the chain\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {Function}  c           first function in the chain\r\n\t\t */\r\n\t\tpipe        =   flipAll( compose ),\r\n\r\n\r\n\t\t/**\r\n\t\t * callFirst\r\n\t\t *\r\n\t\t * this will partially apply a function and the first arg, returned function will take\r\n\t\t * remaining arguments and apply to the curried function\r\n\t\t *\r\n\t\t * ` callFirst( Function( ...arguments ), first ) => ( ...arguments ) `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          curried function\r\n\t\t * @param   {*}         first       first argument\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  [{*}]       args        arguments to apply to curried function\r\n \t\t */\r\n\t\tcallFirst   =   ( fn, first ) =>\r\n\t\t\t\t\t\t\t( ...args ) =>\r\n\t\t\t\t\t\t\t\tfn.apply(this, [ first ].concat( args ) ),\r\n\r\n\r\n\t\t/**\r\n\t\t * callLast\r\n\t\t *\r\n\t\t * this will partially apply a function and the last arg, returned function will take\r\n\t\t * remaining arguments and apply to the curried function\r\n\t\t *\r\n\t\t * ` callFirst( Function( ...arguments ), last ) => ( ...arguments ) `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          curried function\r\n\t\t * @param   {*}         last        last argument\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  [{*}]       args        arguments to apply to curried function\r\n\t\t */\r\n\t\tcallLast    =   ( fn, last ) =>\r\n\t\t\t\t\t\t\t( ...args ) =>\r\n\t\t\t\t\t\t\t\tfn.apply(this, args.concat( [ last ] ) ),\r\n\r\n\r\n\t\t/**\r\n\t\t * curryOne\r\n\t\t *\r\n\t\t * this function will curry a function taking one argument\r\n\t\t *\r\n\t\t * ` curryOne( Function ) => ( *:arg ) `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to curry\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {*]         arg         argument to apply to curried function\r\n\t\t *\r\n\t\t *      @returns {*}                    return from curried function\r\n \t\t */\r\n\t\tcurryOne    =   ( fn ) =>\r\n\t\t\t\t\t\t\t( arg ) =>\r\n\t\t\t\t\t\t\t\tfn.call( this, arg ),\r\n\r\n\r\n\t\t/**\r\n\t\t * curryOne\r\n\t\t *\r\n\t\t * this function will curry a function taking one argument\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to curry\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {*]         arg         argument to apply to curried function\r\n\t\t *\r\n\t\t *      @returns {*}                    return from curried function\r\n\t\t */\r\n\t\tcurryTwo    =   ( fn ) =>\r\n              ( arg ) =>\r\n                callFirst(fn, arg ),\r\n\r\n\r\n\t\t/**\r\n\t\t * curryThree\r\n\t\t *\r\n\t\t * this function will curry a function taking three arguments\r\n\t\t *\r\n\t\t * ` curryTwo( Function ) => ( first ) => ( second ) => ( third ); `\r\n\t\t *\r\n\t\t * @param   {Function}  fn          function to curry\r\n\t\t *\r\n\t\t * @returns {Function}      curryTwo\r\n \t\t */\r\n\t\tcurryThree  =   ( fn ) =>\r\n\t\t\t\t\t\t\t( arg ) =>\r\n\t\t\t\t\t\t\t\tcurryTwo(callFirst(fn, arg )),\r\n\r\n\r\n\t\t/**\r\n\t\t * fluent\r\n\t\t *\r\n\t\t * this decorator will return the owning object if no return\r\n\t\t * value is given to the curried function\r\n\t\t *\r\n\t\t * @param {Function}    method      method to decorate\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  [{*}]       args        arguments for curried method\r\n\t\t *\r\n\t\t *      @returns    {*}                 value of this abj\r\n \t\t */\r\n\t\tfluent      =   ( method ) =>\r\n\t\t\t\t\t\t\tfunction fluent( ...args ){\r\n\t\t\t\t\t\t\t\tvar ret = method.apply( this, args );\r\n\t\t\t\t\t\t\t\treturn typeof ret !== 'undefined'\r\n\t\t\t\t\t\t\t\t\t? ret\r\n\t\t\t\t\t\t\t\t\t: this\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t/**\r\n\t\t * maybe\r\n\t\t *\r\n\t\t * this function will only execute the curried function on an object\r\n\t\t * if none of the arguments are nully\r\n \t\t */\r\n\t\tmaybe       =   ( fn ) =>\r\n\t\t\t\t\t\t\tfunction maybe( ...args ){\r\n\t\t\t\t\t\t\t\treturn args.length === 0 || containsNully( args )\r\n\t\t\t\t\t\t\t\t\t? void 0\r\n\t\t\t\t\t\t\t\t\t: fn.apply(this, args );\r\n\t\t\t\t\t\t\t},\r\n\r\n\r\n\t\tcurriedMapWith =    curryTwo( flip( map ) ),\r\n\r\n\t\t/**\r\n\t\t * setter\r\n\t\t *\r\n\t\t * this decorator will only set a property's value if the arguments are\r\n\t\t * not null, and will return the value or this for fluent chaining\r\n\t\t */\r\n\t\tsetter      =       compose( fluent, maybe ),\r\n\r\n\t\t/**\r\n\t\t * not\r\n\t\t *\r\n\t\t * this function will return the inverse of the curried function\r\n\t\t *\r\n\t\t * @param {Function}    fn          function to curry\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  {*}         args        arguments to apply to curried function\r\n \t\t */\r\n\t\tnot         =   ( fn ) =>\r\n\t\t\t\t\t\t\tfunction( ...args ){\r\n\t\t\t\t\t\t\t\treturn !fn.apply( this, args );\r\n\t\t\t\t\t\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * bind\r\n\t\t *\r\n\t\t * this function will bind arguments to a curried function\r\n\t\t *\r\n\t\t * ` bind( Function [, *:...bound] ) => ( *:...passed ) `\r\n\t\t *\r\n\t\t * @param {Function}    fn          function to curry\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param  [{*}]       bound       arguments to bind to curried function\r\n\t\t *\r\n\t\t *      @returns {Function}\r\n\t\t *\r\n\t\t *          @param [{*}]        passed      arguments passed when calling bound function\r\n\t\t *\r\n\t\t *          @returns {*}                    result of curried function\r\n \t\t */\r\n\t\tbind        =   ( fn ) =>\r\n\t\t\t\t\t\t\t( ...bound ) =>\r\n\t\t\t\t\t\t\t\tfunction( ...passed ) {\r\n\t\t\t\t\t\t\t\t\treturn fn.apply(this, bound.concat( passed ))\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t * typeIs\r\n\t\t *\r\n\t\t * this function will curry a property value, and return a function that takes\r\n\t\t * a value to compare.\r\n\t\t *\r\n\t\t * `typeIs( *:prop ) => ( *:val )`\r\n\t\t *\r\n\t\t * @param {*}       prop            a type of object\r\n\t\t *\r\n\t\t * @returns {Function}\r\n\t\t *\r\n\t\t *      @param {*}       val             a value to check against the type\r\n\t\t *\r\n\t\t *      @returns {Boolean}\r\n \t\t */\r\n\t\ttypeIs      =   ( prop ) =>\r\n\t\t\t\t\t\t\t( val ) =>\r\n\t\t\t\t\t\t\t\ttypeof val === prop,\r\n\r\n\r\n\t\tisInstance  =   ( instance ) =>\r\n\t\t\t\t\t\t\t( thing ) =>\r\n\t\t\t\t\t\t\t\tthing instanceof instance,\r\n\r\n\r\n\t\tisUndefined =   typeIs( 'undefined' ),\r\n\r\n\r\n\t\tnotUndefined=   not(isUndefined),\r\n\r\n\r\n\t\tisFunction  =   typeIs('function'),\r\n\r\n\t\tisElement   =   isInstance(HTMLElement),\r\n\t\tisNodeList  =   isInstance(NodeList),\r\n\r\n\t\tisString    =   typeIs('string'),\r\n\r\n\t\tisNully = ( val ) => val == null,\r\n\t\tnullyFilter = filterWith( not(isNully) ),\r\n\t\tcount = ( thing ) => thing.length,\r\n\t\tcontainsNully = compose( count, filterWith( isNully ) ),\r\n\r\n\t\t/**\r\n\t\t * this function will return an array of the values not\r\n\t\t * contained in the input array\r\n\t\t *\r\n\t\t * @param   {Array}     arr         array to check\r\n\t\t * @param   {Array}     values      array to compare\r\n\t\t *\r\n\t\t * @returns {Array}     values not in input array\r\n \t\t */\r\n\t\tnotIn       = (arr, ...values ) =>\r\n\t\t\tvalues.filter(( item ) => arr.indexOf(item) > -1 ),\r\n\r\n\r\n\t\tcombine     =   ( arr ) =>\r\n\t\t\t\t\t\t\t( ...values ) => {\r\n\t\t\t\t\t\t\t\tvar index = null;\r\n\t\t\t\t\t\t\t\tvalues = arr.concat( notIn(arr, values ));\r\n\t\t\t\t\t\t\t},\r\n\r\n\r\n\t\tdiff        =   ( one, two ) =>\r\n\t\t\t\t\t\t\tone < two\r\n\t\t\t\t\t\t\t\t? two - one\r\n\t\t\t\t\t\t\t\t: ( one - two ) * -1,\r\n\r\n\t\tdiffArray   =   (left, right) => {\r\n\t\t\t\t\t\t\tvar ret = [],\r\n\t\t\t\t\t\t\t\tii = 0,\r\n\t\t\t\t\t\t\t\tll = left.length;\r\n\r\n\t\t\t\t\t\t\tfor( ; ii < ll; ii++ ){\r\n\t\t\t\t\t\t\t\tvar l = left[ii],\r\n\t\t\t\t\t\t\t\t\t\tr = right[ii];\r\n\r\n\t\t\t\t\t\t\t\tif( l && isNaN(r)){\r\n\t\t\t\t\t\t\t\t\tright = l;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if( r && isNaN(l)){\r\n\t\t\t\t\t\t\t\t\tleft = r;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tret = ret.concat( diff( l, r ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\t\t},\r\n\r\n\r\n\t\tgetSet      =   ( prop, fn ) => {\r\n\t\t\t\t\t\t\treturn fluent(function( val ){\r\n\t\t\t\t\t\t\t\tif( isUndefined( val ) ){\r\n\t\t\t\t\t\t\t\t\treturn this[ prop ];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\textend( this[ prop ], val );\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t},\r\n\r\n\r\n\t\tcapitalize  =   ( str ) =>\r\n\t\t\t\t\t\t\tstr.replace(/(\\w)(\\w*)/, ( matches, first, rest) =>\r\n\t\t\t\t\t\t\t\tfirst.toUpperCase() + rest ),\r\n\r\n\r\n\t    crossBrowser =  (...browsers) =>\r\n\t\t\t\t\t\t    ( prop ) =>\r\n\t\t\t\t\t\t\t    ( el, value ) => {\r\n\t\t\t\t\t\t\t\t    browsers.forEach(( browser ) =>\r\n\t\t\t\t\t\t\t\t\t    el.style[browser + '-' + capitalize( prop ) ] = value );\r\n\r\n\t\t\t\t\t\t\t\t    el.style[ prop ] = value;\r\n\t                            },\r\n\r\n\r\n\t    allBrowsers =   crossBrowser('webkit', 'moz', 'ms' ),\r\n\r\n\r\n\t    transform   =   allBrowsers('transform');\r\n\r\n\r\n\tfunction extend( reciever, ...givers ){\r\n\t\treturn givers.reduce(function( reciever, giver ){\r\n\r\n\t\t\tfor( var key in giver ){\r\n\t\t\t\treciever[ key ] = giver[ key ];\r\n\t\t\t}\r\n\r\n\t\t\treturn reciever;\r\n\r\n\t\t}, reciever )\r\n\t}\r\n\r\n\r\n\r\n\textend.fluent = function( reciever, ...givers ){\r\n\t\treturn givers.reduce( function( reciever, giver ){\r\n\r\n\t\t\tfor( var key in giver ) {\r\n\t\t\t\treciever[ key ] = fluent(giver[ key ]);\r\n\t\t\t}\r\n\r\n\t\t\treturn reciever;\r\n\r\n\t\t}, reciever )\r\n\t};\r\n\r\n\r\n\t// this should force re compiling force again bitches"]}